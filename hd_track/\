import numpy as np
import scipy.sparse as ss

def compute_cost(hydra_tfms, ar_tfms):

    """
    Returns the cost matrix given two lists of transforms by computing the Euclidean distance of the translation component in the tfm.
    """
    print hydra_tfms[0]
    return 0


def optimal_warp_path(cost):

    """
    Returns the optimal warping path using dynamic time warp with cost function as input.
    """
    m,n = cmat_mn.shape

    nsteps =m+n-1
    dtw_path = ss.dok_matrix(cmat_mn.shape)
    dtw_path[m-1,n-1] = 1
    
    pm,pn = m-1,n-1
    for _ in xrange(nsteps-2, -1,-1):
        if pm==pn==0:
            return dtw_path
        if pm == 0:
            dtw_path[pm,pn-1] = 1
            pn -= 1
        elif pn == 0:
            dtw_path[pm-1,pn] = 1
            pm -= 1
        else:
            arg_min = np.argmin((cmat_mn[pm-1, pn], cmat_mn[pm, pn-1], cmat_mn[pm-1, pn-1]))
            if arg_min==0:
                dtw_path[pm-1, pn] = 1
                pm -=1
            if arg_min==1:
                dtw_path[pm, pn-1] = 1
                pn -= 1
            elif arg_min==2:
                dtw_path[pm-1, pn-1] = 1
                pn -= 1
                pm -= 1
    return dtw_path
